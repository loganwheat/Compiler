import java_cup.runtime.*;

terminal CLASS;
terminal FINAL;
terminal VOID;
terminal INT;
terminal CHAR;
terminal BOOL;
terminal FLOAT;
terminal IF;
terminal FI;
terminal WHILE;
terminal RETURN;
terminal ELSE;
terminal TRUE;
terminal FALSE;
terminal READ;
terminal PRINT;
terminal PRINTL;

terminal SEMI;
terminal COMMA;
terminal OPENP;
terminal CLOSEP;
terminal OPENSB;
terminal CLOSESB;
terminal OPENCB;
terminal CLOSECB;
terminal TILDE;
terminal ASSMNT;
terminal MULT;
terminal DIV;
terminal PLUS;
terminal PREFIXPLUS;
terminal MINUS;
terminal PREFIXMINUS;
terminal LESSTHAN;
terminal GREATERTHAN;
terminal LEQ;
terminal GEQ;
terminal EQUALTO;
terminal ANGLEB;
terminal OR;
terminal AND;
terminal INCREMENT;
terminal DECREMENT;
terminal QUESTIONMARK;
terminal COLON;

terminal int INTLIT;
terminal String ID;
terminal String CHARLIT;
terminal double FLOATLIT;
terminal String STRLIT;

//----------------

non terminal Program program;
non terminal Memberdecls memberdecls;
non terminal Fielddecls fielddecls;
non terminal Methoddecls methoddecls;
non terminal Fielddecl fielddecl;
non terminal Optionalexpr optionalexpr;
non terminal Methoddecl methoddecl;
non terminal Optionalsemi optionalsemi;
non terminal Returntype returntype;
non terminal Type type;
non terminal Argdecls argdecls;
non terminal ArgdeclList argdeclList;
non terminal Argdecl argdecl;
non terminal Stmts stmts;
non terminal Stmt stmt;
non terminal IfEnd ifEnd;
non terminal Name name;
non terminal Args args;
non terminal Readlist readlist;
non terminal Printlist printlist;
non terminal Printlinelist printlinelist;
non terminal Expr expr;
non terminal Binaryop binaryop;

precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left LESSTHAN, LEQ, GREATERTHAN, GEQ;
precedence left EQUALTO, ANGLEB;
precedence left AND, OR;

program ::=
		CLASS ID:i OPENCB memberdecls:md CLOSECB
		{: RESULT = new Program(i, md); :}
		;

memberdecls ::=
	    fielddecls:fd methoddecls:md
	    {: RESULT = new Memberdecls(fd, md); :}
	    ;

fielddecls ::=
	   	fielddecl:fd fielddecls:fds
	   	{: RESULT = new Fielddecls(fd, fds); :}
	   	|
		fielddecl:fd
	   	{: RESULT = new Fielddecls(fd, null); :}
	   	;

methoddecls ::=
	    methoddecl:md methoddecls:mds
	    {: RESULT = new Methoddecls(md, mds); :}
	    |
	    {: RESULT = new Methoddecls(); :}
	    ;

fielddecl ::=
		FINAL type:t ID:i optionalexpr:oe SEMI
		{: RESULT = new Fielddecl(t, i, oe); :}
		|
	  	type:t ID:i optionalexpr:oe SEMI
	  	{: RESULT = new Fielddecl(t, i, oe); :}
	  	|
	  	type:t ID:i OPENSB INTLIT:il CLOSESB SEMI
	  	{: RESULT = new Fielddecl(t, i, il); :}
	  	;

optionalexpr ::=
		ASSMNT expr:e
		{: RESULT = new Optionalexpr(e); :}
		|
		{: RESULT = new Optionalexpr(); :}
		;

methoddecl ::=
		returntype:rt OPENP argdecls:a CLOSEP OPENCB fielddecls:fds stmts:s CLOSECB optionalsemi:os
		{: RESULT = new Methoddecl(rt, a, fds, s, os); :}
		;

optionalsemi ::=
		SEMI
		{: RESULT = new Optionalsemi(";"); :}
		|
		{: RESULT = new Optionalsemi(); :}
		;

returntype ::=
		type:t
		{: RESULT = new Returntype(t); :}
		|
		VOID
		{: RESULT = new Returntype("void"); :}
		;

type ::=
		INT
		{: RESULT = new Type(1); :}
		|
		CHAR
		{: RESULT = new Type(2); :}
		|
		BOOL
		{: RESULT = new Type(3); :}
		|
		FLOAT
		{: RESULT = new Type(4); :}
		;

argdecls ::=
		argdeclList:al
		{: RESULT = new Argdecls(al); :}
		|
		{: RESULT = new Argdecls(); :}
		;

argdeclList ::=
		argdecl:a COMMA argdeclList:al
		{: RESULT = new ArgdeclList(a, al); :}
		|
		argdecl:a
		{: RESULT = new ArgdeclList(a); :}
		;

argdecl ::=
		type:t ID:i
		{: RESULT = new Argdecl(t, i); :}
		|
		type:t ID:i OPENSB CLOSESB
		{: RESULT = new Argdecl(t, i); :}
		;

stmts ::=
		stmt:s stmts:ss
		{: RESULT = new Stmts(s, ss); :}
		|
		{: RESULT = new Stmts(); :}
		;

stmt ::= 
		IF OPENP expr:e CLOSEP stmt:s ifEnd:ie
		{: RESULT = new Stmt(e, s, ie); :}
		|
		WHILE OPENP expr:e CLOSEP stmt:s
		{: RESULT = new Stmt(e, s); :}
		|
		name:n ASSMNT expr:e SEMI
		{: RESULT = new Stmt(n, e); :}
		|
		READ OPENP readlist:rl CLOSEP SEMI
		{: RESULT = new Stmt(rl); :}
		|
		PRINT OPENP printlist:pl CLOSEP SEMI
		{: RESULT = new Stmt(pl); :}
		|
		PRINTL OPENP printlinelist:pll CLOSEP SEMI
		{: RESULT = new Stmt(pll); :}
		|
		ID:i OPENP CLOSEP SEMI
		{: RESULT = new Stmt(i); :}
		|
		ID:i OPENP args:a CLOSEP SEMI
		{: RESULT = new Stmt(i, a); :}
		|
		RETURN SEMI
		{: RESULT = new Stmt(); :}
		|
		RETURN expr:e SEMI
		{: RESULT = new Stmt(e); :}
		|
		name:n INCREMENT SEMI
		{: RESULT = new Stmt(n); :}
		|
		name:n DECREMENT SEMI
		{: RESULT = new Stmt(n); :}
		|
		OPENCB fielddecls:fds CLOSECB optionalsemi:os
		{: RESULT = new Stmt(fds, os); :}
		;

ifEnd ::=
		ELSE stmt:s FI
		{: RESULT = new IfEnd(s); :}
		|
		FI
		{: RESULT = new IfEnd(); :}
		;

name ::=
		ID:i
		{: RESULT = new Name(i); :}
		|
		ID:i OPENSB expr:e CLOSESB
		{: RESULT = new Name(i, e); :}
		;

args ::=
		expr:e COMMA args:a
		{: RESULT = new Args(e, a); :}
		|
		expr:e
		{: RESULT = new Args(e); :}
		;

readlist ::=
		name:n COMMA args:a
		{: RESULT = new Readlist(n, a); :}
		|
		name:n
		{: RESULT = new Readlist(n); :}
		;

printlist ::=
		expr:e COMMA readlist:rl
		{: RESULT = new Printlist(e, rl); :}
		|
		expr:e
		{: RESULT = new Printlist(e); :}
		;

expr ::= 
		name:n
		{: RESULT = new Expr(n); :}
		|
		ID:i OPENP CLOSEP
		{: RESULT = new Expr(i); :}
		|
		ID:i OPENP args:a CLOSEP
		{: RESULT = new Expr(i, a); :}
		|
		INTLIT:i
		{: RESULT = new Expr(i); :}
		|
		CHARLIT:c
		{: RESULT = new Expr(c); :}
		|
		STRLIT:s
		{: RESULT = new Expr(s); :}
		|
		FLOATLIT:f
		{: RESULT = new Expr(f); :}
		|
		TRUE
		{: RESULT = new Expr(true); :}
		|
		FALSE
		{: RESULT = new Expr(false); :}
		|
		OPENP expr:e CLOSEP
		{: RESULT = new Expr(e); :}
		|
		TILDE expr:e
		{: RESULT = new Expr(e); :}
		|
		PREFIXMINUS expr:e
		{: RESULT = new Expr(e); :}
		|
		PREFIXPLUS expr:e
		{: RESULT = new Expr(e); :}
		|
		OPENP type:t CLOSEP expr:e
		{: RESULT = new Expr(t, e); :}
		|
		binaryop:b
		{: RESULT = new Expr(b); :}
		|
		OPENP expr:e1 QUESTIONMARK expr:e2 COLON expr:e3 CLOSEP
		{: RESULT = new Expr(e1, e2, e3); :}
		;

binaryop ::= 
		expr:lhs MULT expr:rhs
		{: RESULT = new Binaryop(lhs, "*", rhs); :}
		|
		expr:lhs DIV expr:rhs
		{: RESULT = new Binaryop(lhs, "/", rhs); :}
		|
		expr:lhs PLUS expr:rhs
		{: RESULT = new Binaryop(lhs, "+", rhs); :}
		|
		expr:lhs MINUS expr:rhs
		{: RESULT = new Binaryop(lhs, "-", rhs); :}
		|
		expr:lhs LESSTHAN expr:rhs
		{: RESULT = new Binaryop(lhs, "<", rhs); :}
		|
		expr:lhs GREATERTHAN expr:rhs
		{: RESULT = new Binaryop(lhs, ">", rhs); :}
		|
		expr:lhs LEQ expr:rhs
		{: RESULT = new Binaryop(lhs, "<=", rhs); :}
		|
		expr:lhs GEQ expr:rhs
		{: RESULT = new Binaryop(lhs, ">=", rhs); :}
		|
		expr:lhs EQUALTO expr:rhs
		{: RESULT = new Binaryop(lhs, "==", rhs); :}
		|
		expr:lhs ANGLEB expr:rhs
		{: RESULT = new Binaryop(lhs, "<>", rhs); :}
		|
		expr:lhs OR expr:rhs
		{: RESULT = new Binaryop(lhs, "||", rhs); :}
		|
		expr:lhs AND expr:rhs
		{: RESULT = new Binaryop(lhs, "&&", rhs); :}
		;